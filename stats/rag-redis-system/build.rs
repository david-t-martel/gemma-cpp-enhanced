use std::env;
use std::path::PathBuf;

fn main() {
    // Generate C bindings if cbindgen is available and ffi feature is enabled
    #[cfg(feature = "ffi")]
    {
        use std::process::Command;

        let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let package_name = env::var("CARGO_PKG_NAME").unwrap();
        let output_file = target_dir()
            .join("include")
            .join(format!("{package_name}.h"));

        // Create include directory
        std::fs::create_dir_all(output_file.parent().unwrap())
            .expect("Failed to create include directory");

        // Check if cbindgen is available
        if Command::new("cbindgen").arg("--version").output().is_ok() {
            println!("cargo:rerun-if-changed=src/");
            println!("cargo:rerun-if-changed=cbindgen.toml");

            let config = cbindgen::Config::from_file("cbindgen.toml").unwrap_or_else(|_| {
                println!("cargo:warning=cbindgen.toml not found, using default config");
                cbindgen::Config {
                    language: cbindgen::Language::C,
                    header: Some(
                        "/* Automatically generated C bindings for RAG Redis System */".to_string(),
                    ),
                    include_guard: Some("RAG_REDIS_BINDINGS_H".to_string()),
                    autogen_warning: Some(
                        "/* Warning: This file is automatically generated. Do not edit! */"
                            .to_string(),
                    ),
                    includes: vec!["stdint.h".to_string(), "stdbool.h".to_string()],
                    ..Default::default()
                }
            });

            cbindgen::generate_with_config(&crate_dir, config)
                .expect("Unable to generate bindings")
                .write_to_file(&output_file);

            println!("Generated C bindings: {}", output_file.display());
        } else {
            println!("cargo:warning=cbindgen not found, skipping C binding generation");
        }
    }

    // Link against required system libraries
    if cfg!(target_os = "windows") {
        println!("cargo:rustc-link-lib=ws2_32");
        println!("cargo:rustc-link-lib=userenv");
    } else if cfg!(target_os = "macos") {
        println!("cargo:rustc-link-lib=framework=Security");
        println!("cargo:rustc-link-lib=framework=CoreFoundation");
    }

    // Set up library search paths
    if let Ok(redis_lib_dir) = env::var("REDIS_LIB_DIR") {
        println!("cargo:rustc-link-search=native={redis_lib_dir}");
    }

    // Export library paths for FFI
    println!(
        "cargo:rustc-env=FFI_HEADER_PATH={}",
        target_dir().join("include").display()
    );

    // Rerun if build script changes
    println!("cargo:rerun-if-changed=build.rs");
}

fn target_dir() -> PathBuf {
    let out_dir = env::var("OUT_DIR").unwrap();
    let target_dir = PathBuf::from(out_dir)
        .ancestors()
        .nth(3)
        .unwrap()
        .to_path_buf();
    target_dir
}

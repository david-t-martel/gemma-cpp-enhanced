#version 450

/**
 * Matrix Multiplication Compute Shader
 * Performs C = alpha * A * B + beta * C
 *
 * Layout:
 * - A: [M x K] matrix
 * - B: [K x N] matrix
 * - C: [M x N] matrix (input/output)
 */

// Workgroup size - optimized for most GPUs
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

// Uniform buffer for parameters
layout(set = 0, binding = 0) uniform UniformBuffer {
    uint M;           // Rows of A, rows of C
    uint N;           // Columns of B, columns of C
    uint K;           // Columns of A, rows of B
    float alpha;      // Scale factor for A*B
    float beta;       // Scale factor for existing C
} ubo;

// Storage buffers for matrices
layout(set = 0, binding = 1, std430) restrict readonly buffer MatrixA {
    float A[];
};

layout(set = 0, binding = 2, std430) restrict readonly buffer MatrixB {
    float B[];
};

layout(set = 0, binding = 3, std430) restrict buffer MatrixC {
    float C[];
};

// Shared memory for tile-based computation
shared float tileA[16][16];
shared float tileB[16][16];

void main() {
    // Get global thread coordinates
    uint row = gl_GlobalInvocationID.y;
    uint col = gl_GlobalInvocationID.x;

    // Get local thread coordinates within workgroup
    uint localRow = gl_LocalInvocationID.y;
    uint localCol = gl_LocalInvocationID.x;

    // Check bounds
    if (row >= ubo.M || col >= ubo.N) {
        return;
    }

    float sum = 0.0;

    // Number of tiles needed to cover K dimension
    uint numTiles = (ubo.K + 15) / 16;

    // Iterate through tiles
    for (uint tile = 0; tile < numTiles; ++tile) {
        // Calculate global coordinates for this tile
        uint aCol = tile * 16 + localCol;
        uint bRow = tile * 16 + localRow;

        // Load tile from matrix A into shared memory
        if (row < ubo.M && aCol < ubo.K) {
            tileA[localRow][localCol] = A[row * ubo.K + aCol];
        } else {
            tileA[localRow][localCol] = 0.0;
        }

        // Load tile from matrix B into shared memory
        if (bRow < ubo.K && col < ubo.N) {
            tileB[localRow][localCol] = B[bRow * ubo.N + col];
        } else {
            tileB[localRow][localCol] = 0.0;
        }

        // Synchronize to ensure all threads have loaded their data
        barrier();

        // Compute partial dot product for this tile
        for (uint k = 0; k < 16; ++k) {
            sum += tileA[localRow][k] * tileB[k][localCol];
        }

        // Synchronize before loading next tile
        barrier();
    }

    // Write result to matrix C
    uint cIndex = row * ubo.N + col;
    if (ubo.beta == 0.0) {
        C[cIndex] = ubo.alpha * sum;
    } else {
        C[cIndex] = ubo.alpha * sum + ubo.beta * C[cIndex];
    }
}